package pdf

import (
	"fmt"
	"time"

	"go-service/pkg/models"

	"github.com/jung-kurt/gofpdf"
)

// Generator handles PDF generation for student reports
type Generator struct {
	pdf *gofpdf.Fpdf
}

// NewGenerator creates a new PDF generator
func NewGenerator() *Generator {
	pdf := gofpdf.New("P", "mm", "A4", "")
	return &Generator{
		pdf: pdf,
	}
}

// GenerateStudentReport creates a PDF report for a student
func (g *Generator) GenerateStudentReport(student *models.Student) ([]byte, error) {
	// Initialize PDF
	g.pdf.AddPage()
	g.pdf.SetFont("Arial", "B", 16)

	// Title
	g.pdf.Cell(0, 10, "STUDENT REPORT")
	g.pdf.Ln(20)

	// School Header
	g.pdf.SetFont("Arial", "B", 14)
	g.pdf.Cell(0, 8, "School Management System")
	g.pdf.Ln(15)

	// Student Basic Information
	g.addSectionHeader("STUDENT INFORMATION")
	g.addField("Student ID", fmt.Sprintf("%d", student.ID))
	g.addField("Full Name", student.Name)
	g.addField("Email", student.Email)
	g.addField("Phone", student.Phone)
	g.addField("Gender", student.Gender)
	g.addField("Date of Birth", g.formatDate(student.DOB))
	
	g.pdf.Ln(10)

	// Academic Information
	g.addSectionHeader("ACADEMIC INFORMATION")
	g.addField("Class", student.Class)
	g.addField("Section", student.Section)
	g.addField("Roll Number", fmt.Sprintf("%d", student.Roll))
	g.addField("Admission Date", g.formatDate(student.AdmissionDate))
	g.addField("System Access", g.formatBool(student.SystemAccess))

	g.pdf.Ln(10)

	// Family Information
	g.addSectionHeader("FAMILY INFORMATION")
	g.addField("Father's Name", student.FatherName)
	g.addField("Father's Phone", student.FatherPhone)
	g.addField("Mother's Name", student.MotherName)
	g.addField("Mother's Phone", student.MotherPhone)
	g.addField("Guardian's Name", student.GuardianName)
	g.addField("Guardian's Phone", student.GuardianPhone)
	g.addField("Relation to Guardian", student.RelationOfGuardian)

	g.pdf.Ln(10)

	// Address Information
	g.addSectionHeader("ADDRESS INFORMATION")
	g.addField("Current Address", student.CurrentAddress)
	g.addField("Permanent Address", student.PermanentAddress)

	g.pdf.Ln(10)

	// Additional Information
	g.addSectionHeader("ADDITIONAL INFORMATION")
	g.addField("Class Teacher/Reporter", student.ReporterName)

	// Footer
	g.addFooter()

	// Get PDF as bytes
	var buf []byte
	var err error
	
	// Use OutputFileAndClose with a temporary approach
	buf, err = g.getPDFBytes()
	if err != nil {
		return nil, fmt.Errorf("failed to generate PDF: %w", err)
	}

	return buf, nil
}

// addSectionHeader adds a section header to the PDF
func (g *Generator) addSectionHeader(title string) {
	g.pdf.SetFont("Arial", "B", 12)
	g.pdf.SetFillColor(230, 230, 230)
	g.pdf.CellFormat(0, 8, title, "1", 1, "L", true, 0, "")
	g.pdf.Ln(5)
}

// addField adds a field with label and value to the PDF
func (g *Generator) addField(label, value string) {
	g.pdf.SetFont("Arial", "B", 10)
	g.pdf.Cell(50, 6, label+":")
	
	g.pdf.SetFont("Arial", "", 10)
	g.pdf.Cell(0, 6, value)
	g.pdf.Ln(8)
}

// addFooter adds a footer to the PDF
func (g *Generator) addFooter() {
	g.pdf.Ln(20)
	g.pdf.SetFont("Arial", "I", 8)
	g.pdf.Cell(0, 5, "Generated on: "+time.Now().Format("January 2, 2006 at 3:04 PM"))
	g.pdf.Ln(5)
	g.pdf.Cell(0, 5, "Report generated by Go PDF Report Service")
}

// formatDate formats a time.Time to a readable string
func (g *Generator) formatDate(t time.Time) string {
	if t.IsZero() {
		return "Not specified"
	}
	return t.Format("January 2, 2006")
}

// formatBool formats a boolean to a readable string
func (g *Generator) formatBool(b bool) string {
	if b {
		return "Yes"
	}
	return "No"
}

// getPDFBytes returns the PDF as a byte slice
func (g *Generator) getPDFBytes() ([]byte, error) {
	// Create a buffer to capture the PDF output
	var buf []byte
	
	// This is a simplified approach - in a real implementation,
	// you might want to use a proper buffer or temporary file
	err := g.pdf.Output(&PDFBuffer{&buf})
	if err != nil {
		return nil, err
	}
	
	return buf, nil
}

// PDFBuffer implements io.Writer for capturing PDF output
type PDFBuffer struct {
	data *[]byte
}

// Write implements io.Writer interface
func (pb *PDFBuffer) Write(p []byte) (n int, err error) {
	*pb.data = append(*pb.data, p...)
	return len(p), nil
} 